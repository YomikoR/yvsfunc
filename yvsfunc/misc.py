from typing import Any, Callable, List, NoReturn, Optional, Union
import vapoursynth as vs
core = vs.core
from vsutil import fallback, get_depth, iterate, join, plane, scale_value
from functools import partial

__all__ = [
    'repair',
    'bic_blur',
    'pl_deband',
    'DescaleAA_mask',
    'non_telop_mask',
]

def y_error_msg(func_name: str, message: Any) -> NoReturn:
    raise ValueError(func_name + ': ' + str(message))


def y_param_to_list(func_name: str, value: Optional[Union[int, float]]) -> List[Union[int, float]]:
    if isinstance(value, list):
        if len(value) == 0:
            y_error_msg(func_name, 'input list is empty')
        while len(value) < 3:
            value.append(value[-1])
        return value
    else:
        return [value] * 3


def repair(clip: vs.VideoNode, repairclip: vs.VideoNode, mode: Union[int, List[int]] = 1, pixel: Optional[float] = None, planes: Optional[Union[int, List[int]]] = None) -> vs.VideoNode:
    func_name = 'repair'
    if mode < 0:
        return repair(clip, repairclip, mode=-mode, pixel=pixel, planes=planes)
    elif mode == 0:
        return clip
    else:
        if pixel is None:
            import rgvs
            return rgvs.repair(clip, repairclip, mode, planes)
        else:
            return core.sprep.spRepair(clip, repairclip, mode, pixel)


def bic_blur(clip: vs.VideoNode, b: float = 1, it: int = 1) -> vs.VideoNode:
    blur_ker = partial(core.fmtc.resample, kernel='bicubic', a1=b, a2=0, fh=-1, fv=-1)
    return iterate(clip, blur_ker, it)


def pl_deband(clip: vs.VideoNode, planes: List[int] = [0, 1, 2], it: Union[int, List[int]] = 3, thr: Union[int, List[int]] = 4, rad: Union[int, List[int]] = [20, 12], grain: Union[int, List[int]] = 3) -> vs.VideoNode:
    '''
    Yet another wrapper for placebo.Deband
    '''
    func_name = 'pl_deband'
    it = y_param_to_list(func_name, it)
    thr = y_param_to_list(func_name, thr)
    rad = y_param_to_list(func_name, rad)
    if clip.format.color_family in [vs.RGB, vs.GRAY] or isinstance(grain, list):
        grain = y_param_to_list(func_name, grain)
    else:
        # Don't add grain to chroma planes unless intended
        grain = [grain, 0, 0]
    def _deband(planeno):
        if planeno in planes:
            return core.placebo.Deband(plane(clip, planeno), planes=1, iterations=it[planeno], threshold=thr[planeno], radius=rad[planeno], grain=grain[planeno])
        else:
            return plane(clip, planeno)
    debanded = [_deband(num) for num in range(clip.format.num_planes)]
    return join(debanded, family=clip.format.color_family)


def DescaleAA_mask(descale_diff: vs.VideoNode, rescaled: Optional[vs.VideoNode] = None, thr: Union[int, float] = 10, thr_lo: Optional[Union[int, float]] = None, thr_hi: Optional[Union[int, float]] = None, expand: int = 3, inflate: int = 3, pexpand: int = 0, pinflate: int = 0, show_credit: bool = False) -> vs.VideoNode:
    '''
    The mask generated by fvsfunc.DescaleAA
    '''
    bits = get_depth(descale_diff)
    max_val = scale_value(1, 32, bits)
    if bits == 32:
        thr / (235 - 16)
    else:
        thr = thr * max_val // 0xFF
    diffmask = iterate(descale_diff, core.std.Maximum, expand)
    diffmask = iterate(diffmask, core.std.Inflate, inflate)
    if show_credit or rescaled is None:
        return diffmask.std.Binarize(thr)
    thr_lo = fallback(thr_lo, 4 / 0xFF if bits == 32 else 4 * max_val // 0xFF)
    thr_hi = fallback(thr_hi, 24 / 0xFF if bits == 32 else 24 * max_val // 0xFF)
    edgemask = core.std.Prewitt(rescaled, planes=0)
    edgemask = iterate(edgemask, core.std.Maximum, pexpand)
    edgemask = iterate(edgemask, core.std.Inflate, pinflate)
    edgemask = edgemask.std.Expr("x {thrhigh} >= {maxvalue} x {thrlow} <= 0 x ? ?".format(thrhigh=thr_hi, maxvalue=max_val, thrlow=thr_lo))
    return core.std.Expr([diffmask,edgemask], 'x {thr} >= 0 y ?'.format(thr=thr)).std.Inflate().std.Deflate()


def non_telop_mask(src: vs.VideoNode, nc: vs.VideoNode, thr: Union[int, float] = 3, prefilter: Union[Callable[[vs.VideoNode], vs.VideoNode], int] = 0) -> vs.VideoNode:
    if callable(prefilter):
        s = prefilter(src)
        n = prefilter(nc)
    elif prefilter <= 0:
        s = src
        n = nc
    elif prefilter == 1:
        return non_telop_mask(src, nc, thr=thr, prefilter=bic_blur)
    else:
        return non_telop_mask(src, nc, thr=thr, prefilter=partial(core.std.Convolution, matrix=[1] * 9))
    thr = y_param_to_list('non_telop_mask', thr)
    diff = core.std.Expr([s, n], 'x y - abs')
    return core.std.Binarize(diff, thr if s.format.num_planes == 3 else thr[0])
