from typing import Any, Callable, List, NoReturn, Optional, Union
import vapoursynth as vs
core = vs.core
from vsutil import fallback, get_depth, iterate, join, plane, scale_value
from functools import partial

__all__ = [
    'repair',
    'bic_blur',
    'pl_deband',
    'DescaleAA_mask',
    'non_telop_mask',
]

def y_error_msg(func_name: str, message: Any) -> NoReturn:
    raise ValueError(func_name + ': ' + str(message))


def y_param_to_list(func_name: str, value: Optional[Union[int, float]]) -> List[Union[int, float]]:
    if isinstance(value, list):
        if len(value) == 0:
            y_error_msg(func_name, 'input list is empty')
        while len(value) < 3:
            value.append(value[-1])
        return value
    else:
        return [value] * 3

# https://github.com/dnjulek/jvsfunc/blob/164b02aad92d746fed2d56207868ebbe91caa38c/jvsfunc.py#L50-L66
def repair(clip: vs.VideoNode, repairclip: vs.VideoNode, mode: int = 1, pixel: Optional[float] = None) -> vs.VideoNode:
    func_name = 'repair'
    if mode == 0:
        return clip
    elif mode < 0:
        return repair(repairclip, clip, -mode, pixel)
    mode_list = [1, 2, 3, 4, 11, 12, 13, 14]
    if mode not in mode_list:
        y_error_msg(func_name, 'Only modes 1-4 and 11-14 are implemented.')
    if pixel is None:
        sp = False
    else:
        pixel = abs(pixel)
        if pixel > 1.0:
            y_error_msg(func_name, 'Shifting more than 1 pixel is not supported.')
        sp = (pixel != 1.0)
    if sp:
        p = pixel
        q = 1.0 - pixel
        pp = p * p
        qq = q * q
        pq = p * q
        plt = f'y[-1,-1] {pp} * y[-1,0] {pq} * + y[0,-1] {pq} * + y {qq} * + '
        prt = f'y[1,-1] {pp} * y[1,0] {pq} * + y[0,-1] {pq} * + y {qq} * + '
        plb = f'y[-1,1] {pp} * y[-1,0] {pq} * + y[0,1] {pq} * + y {qq} * + '
        prb = f'y[1,1] {pp} * y[1,0] {pq} * + y[0,1] {pq} * + y {qq} * + '
        pl = f'y[-1,0] {p} * y {q} * + '
        pr = f'y[1,0] {p} * y {q} * + '
        pt = f'y[0,-1] {p} * y {q} * + '
        pb = f'y[0,1] {p} * y {q} * + '
        pixels = plt + prt + plb + prb + pl + pr + pt + pb
    else:
        pixels = 'y[-1,-1] y[0,-1] y[1,-1] y[-1,0] y[1,0] y[-1,1] y[0,1] y[1,1] '
    if mode <= 4:
        expr = f'y sort9 dup{9 - mode} max! dup{mode - 1} min! drop9 x min@ max@ clamp'
    else:
        mode = mode - 10
        expr = f'sort8 dup{8 - mode} max! dup{mode - 1} min! drop8 y min@ min ymin! y max@ max ymax! x ymin@ ymax@ clamp'

    return core.akarin.Expr([clip, repairclip], pixels + expr)


def bic_blur(clip: vs.VideoNode, b: float = 1, it: int = 1) -> vs.VideoNode:
    blur_ker = partial(core.fmtc.resample, kernel='bicubic', a1=b, a2=0, fh=-1, fv=-1)
    return iterate(clip, blur_ker, it)


def pl_deband(clip: vs.VideoNode, planes: List[int] = [0, 1, 2], it: Union[int, List[int]] = 3, thr: Union[int, List[int]] = 4, rad: Union[int, List[int]] = [20, 12], grain: Union[int, List[int]] = 3) -> vs.VideoNode:
    '''
    Yet another wrapper for placebo.Deband
    '''
    func_name = 'pl_deband'
    it = y_param_to_list(func_name, it)
    thr = y_param_to_list(func_name, thr)
    rad = y_param_to_list(func_name, rad)
    if clip.format.color_family in [vs.RGB, vs.GRAY] or isinstance(grain, list):
        grain = y_param_to_list(func_name, grain)
    else:
        # Don't add grain to chroma planes unless intended
        grain = [grain, 0, 0]
    def _deband(planeno):
        if planeno in planes:
            return core.placebo.Deband(plane(clip, planeno), planes=1, iterations=it[planeno], threshold=thr[planeno], radius=rad[planeno], grain=grain[planeno])
        else:
            return plane(clip, planeno)
    debanded = [_deband(num) for num in range(clip.format.num_planes)]
    return join(debanded, family=clip.format.color_family)


def DescaleAA_mask(descale_diff: vs.VideoNode, rescaled: Optional[vs.VideoNode] = None, thr: Union[int, float] = 10, thr_lo: Optional[Union[int, float]] = None, thr_hi: Optional[Union[int, float]] = None, expand: int = 3, inflate: int = 3, pexpand: int = 0, pinflate: int = 0, show_credit: bool = False) -> vs.VideoNode:
    '''
    The mask generated by fvsfunc.DescaleAA
    '''
    bits = get_depth(descale_diff)
    max_val = scale_value(1, 32, bits)
    if bits == 32:
        thr / (235 - 16)
    else:
        thr = thr * max_val // 0xFF
    diffmask = iterate(descale_diff, core.std.Maximum, expand)
    diffmask = iterate(diffmask, core.std.Inflate, inflate)
    if show_credit or rescaled is None:
        return diffmask.std.Binarize(thr)
    thr_lo = fallback(thr_lo, 4 / 0xFF if bits == 32 else 4 * max_val // 0xFF)
    thr_hi = fallback(thr_hi, 24 / 0xFF if bits == 32 else 24 * max_val // 0xFF)
    edgemask = core.std.Prewitt(rescaled, planes=0)
    edgemask = iterate(edgemask, core.std.Maximum, pexpand)
    edgemask = iterate(edgemask, core.std.Inflate, pinflate)
    edgemask = edgemask.std.Expr("x {thrhigh} >= {maxvalue} x {thrlow} <= 0 x ? ?".format(thrhigh=thr_hi, maxvalue=max_val, thrlow=thr_lo))
    return core.std.Expr([diffmask,edgemask], 'x {thr} >= 0 y ?'.format(thr=thr)).std.Inflate().std.Deflate()


def non_telop_mask(src: vs.VideoNode, nc: vs.VideoNode, thr: Union[int, float] = 3, prefilter: Union[Callable[[vs.VideoNode], vs.VideoNode], int] = 0) -> vs.VideoNode:
    if callable(prefilter):
        s = prefilter(src)
        n = prefilter(nc)
    elif prefilter <= 0:
        s = src
        n = nc
    elif prefilter == 1:
        return non_telop_mask(src, nc, thr=thr, prefilter=bic_blur)
    else:
        return non_telop_mask(src, nc, thr=thr, prefilter=partial(core.std.Convolution, matrix=[1] * 9))
    thr = y_param_to_list('non_telop_mask', thr)
    diff = core.std.Expr([s, n], 'x y - abs')
    return core.std.Binarize(diff, thr if s.format.num_planes == 3 else thr[0])
